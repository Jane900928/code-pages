{"version":3,"sources":["../src/tools/validation.ts","../src/tools/tool.ts","../src/tools/toolchecks.ts"],"names":[],"mappings":"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","file":"chunk-VGTJE46C.js","sourcesContent":["import type { z } from 'zod';\n\nexport interface ValidationError<T = any> {\n  error: true;\n  message: string;\n  validationErrors: z.ZodFormattedError<T>;\n}\n\n/**\n * Validates input against a Zod schema and returns a structured error if validation fails\n * @param schema The Zod schema to validate against\n * @param input The input to validate\n * @param toolId Optional tool ID for better error messages\n * @returns The validation error object if validation fails, undefined if successful\n */\nexport function validateToolInput<T = any>(\n  schema: z.ZodSchema<T> | undefined,\n  input: unknown,\n  toolId?: string,\n): { data: T | unknown; error?: ValidationError<T> } {\n  if (!schema || !('safeParse' in schema)) {\n    return { data: input };\n  }\n\n  // Extract the actual input data from various context formats\n  let actualInput = input;\n\n  // Handle ToolExecutionContext format { context: data, ... }\n  if (input && typeof input === 'object' && 'context' in input) {\n    actualInput = (input as any).context;\n  }\n\n  // Handle StepExecutionContext format { context: { inputData: data, ... }, ... }\n  if (actualInput && typeof actualInput === 'object' && 'inputData' in actualInput) {\n    actualInput = (actualInput as any).inputData;\n  }\n\n  const validation = schema.safeParse(actualInput);\n  if (!validation.success) {\n    const errorMessages = validation.error.errors\n      .map((e: z.ZodIssue) => `- ${e.path?.join('.') || 'root'}: ${e.message}`)\n      .join('\\n');\n\n    const error: ValidationError<T> = {\n      error: true,\n      message: `Tool validation failed${toolId ? ` for ${toolId}` : ''}. Please fix the following errors and try again:\\n${errorMessages}\\n\\nProvided arguments: ${JSON.stringify(actualInput, null, 2)}`,\n      validationErrors: validation.error.format(),\n    };\n\n    return { data: input, error };\n  }\n\n  // Return the original input structure with validated data in the right place\n  if (input && typeof input === 'object' && 'context' in input) {\n    if ((input as any).context && typeof (input as any).context === 'object' && 'inputData' in (input as any).context) {\n      return { data: { ...input, context: { ...(input as any).context, inputData: validation.data } } };\n    }\n    return { data: { ...input, context: validation.data } };\n  }\n\n  return { data: validation.data };\n}\n","import type { ToolExecutionOptions } from 'ai';\nimport type { z } from 'zod';\n\nimport type { Mastra } from '../mastra';\nimport type { ToolAction, ToolExecutionContext } from './types';\nimport { validateToolInput } from './validation';\n\nexport class Tool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n> implements ToolAction<TSchemaIn, TSchemaOut, TContext>\n{\n  id: string;\n  description: string;\n  inputSchema?: TSchemaIn;\n  outputSchema?: TSchemaOut;\n  execute?: ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'];\n  mastra?: Mastra;\n\n  constructor(opts: ToolAction<TSchemaIn, TSchemaOut, TContext>) {\n    this.id = opts.id;\n    this.description = opts.description;\n    this.inputSchema = opts.inputSchema;\n    this.outputSchema = opts.outputSchema;\n    this.mastra = opts.mastra;\n\n    // Wrap the execute function with validation if it exists\n    if (opts.execute) {\n      const originalExecute = opts.execute;\n      this.execute = async (context: TContext, options?: ToolExecutionOptions) => {\n        // Validate input if schema exists\n        const { data, error } = validateToolInput(this.inputSchema, context, this.id);\n        if (error) {\n          return error as any;\n        }\n\n        return originalExecute(data as TContext, options);\n      };\n    }\n  }\n}\n\nexport function createTool<\n  TSchemaIn extends z.ZodSchema | undefined = undefined,\n  TSchemaOut extends z.ZodSchema | undefined = undefined,\n  TContext extends ToolExecutionContext<TSchemaIn> = ToolExecutionContext<TSchemaIn>,\n  TExecute extends ToolAction<TSchemaIn, TSchemaOut, TContext>['execute'] = ToolAction<\n    TSchemaIn,\n    TSchemaOut,\n    TContext\n  >['execute'],\n>(\n  opts: ToolAction<TSchemaIn, TSchemaOut, TContext> & {\n    execute?: TExecute;\n  },\n): [TSchemaIn, TSchemaOut, TExecute] extends [z.ZodSchema, z.ZodSchema, Function]\n  ? Tool<TSchemaIn, TSchemaOut, TContext> & {\n      inputSchema: TSchemaIn;\n      outputSchema: TSchemaOut;\n      execute: (context: TContext) => Promise<any>;\n    }\n  : Tool<TSchemaIn, TSchemaOut, TContext> {\n  return new Tool(opts) as any;\n}\n","import { Tool } from './tool';\nimport type { ToolToConvert } from './tool-builder/builder';\nimport type { VercelTool } from './types';\n\n/**\n * Checks if a tool is a Vercel Tool\n * @param tool - The tool to check\n * @returns True if the tool is a Vercel Tool, false otherwise\n */\nexport function isVercelTool(tool?: ToolToConvert): tool is VercelTool {\n  // Checks if this tool is not an instance of Tool\n  return !!(tool && !(tool instanceof Tool) && 'parameters' in tool);\n}\n"]}