import type { Span } from '@opentelemetry/api';
import type { RuntimeContext } from '../di/index.js';
import type { ChunkType } from '../stream/types.js';
import type { ExecutionGraph } from './execution-engine.js';
import { ExecutionEngine } from './execution-engine.js';
import type { ExecuteFunction, Step } from './step.js';
import type { Emitter, StepResult } from './types.js';
import type { DefaultEngineType, SerializedStepFlowEntry, StepFlowEntry } from './workflow.js';
export type ExecutionContext = {
    workflowId: string;
    runId: string;
    executionPath: number[];
    suspendedPaths: Record<string, number[]>;
    retryConfig: {
        attempts: number;
        delay: number;
    };
    executionSpan: Span;
};
/**
 * Default implementation of the ExecutionEngine using XState
 */
export declare class DefaultExecutionEngine extends ExecutionEngine {
    /**
     * The runCounts map is used to keep track of the run count for each step.
     * The step id is used as the key and the run count is the value.
     */
    protected runCounts: Map<string, number>;
    /**
     * Get or generate the run count for a step.
     * If the step id is not in the map, it will be added and the run count will be 0.
     * If the step id is in the map, it will return the run count.
     *
     * @param stepId - The id of the step.
     * @returns The run count for the step.
     */
    protected getOrGenerateRunCount(stepId: Step['id']): number;
    protected fmtReturnValue<TOutput>(executionSpan: Span | undefined, emitter: Emitter, stepResults: Record<string, StepResult<any, any, any, any>>, lastOutput: StepResult<any, any, any, any>, error?: Error | string): Promise<TOutput>;
    /**
     * Executes a workflow run with the provided execution graph and input
     * @param graph The execution graph to execute
     * @param input The input data for the workflow
     * @returns A promise that resolves to the workflow output
     */
    execute<TInput, TOutput>(params: {
        workflowId: string;
        runId: string;
        graph: ExecutionGraph;
        serializedStepGraph: SerializedStepFlowEntry[];
        input?: TInput;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        emitter: Emitter;
        retryConfig?: {
            attempts?: number;
            delay?: number;
        };
        runtimeContext: RuntimeContext;
        abortController: AbortController;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<TOutput>;
    getStepOutput(stepResults: Record<string, any>, step?: StepFlowEntry): any;
    executeSleep({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleep';
            id: string;
            duration?: number;
            fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<void>;
    executeSleepUntil({ workflowId, runId, entry, prevOutput, stepResults, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'sleepUntil';
            id: string;
            date?: Date;
            fn?: ExecuteFunction<any, any, any, any, DefaultEngineType>;
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<void>;
    executeWaitForEvent({ event, emitter, timeout, }: {
        event: string;
        emitter: Emitter;
        timeout?: number;
    }): Promise<any>;
    executeStep({ workflowId, runId, step, stepResults, executionContext, resume, prevOutput, emitter, abortController, runtimeContext, skipEmits, writableStream, }: {
        workflowId: string;
        runId: string;
        step: Step<string, any, any>;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        executionContext: ExecutionContext;
        resume?: {
            steps: string[];
            resumePayload: any;
        };
        prevOutput: any;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        skipEmits?: boolean;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<StepResult<any, any, any, any>>;
    executeParallel({ workflowId, runId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'parallel';
            steps: StepFlowEntry[];
        };
        serializedStepGraph: SerializedStepFlowEntry[];
        prevStep: StepFlowEntry;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<StepResult<any, any, any, any>>;
    executeConditional({ workflowId, runId, entry, prevOutput, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        serializedStepGraph: SerializedStepFlowEntry[];
        entry: {
            type: 'conditional';
            steps: StepFlowEntry[];
            conditions: ExecuteFunction<any, any, any, any, DefaultEngineType>[];
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<StepResult<any, any, any, any>>;
    executeLoop({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'loop';
            step: Step;
            condition: ExecuteFunction<any, any, any, any, DefaultEngineType>;
            loopType: 'dowhile' | 'dountil';
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<StepResult<any, any, any, any>>;
    executeForeach({ workflowId, runId, entry, prevOutput, stepResults, resume, executionContext, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        entry: {
            type: 'foreach';
            step: Step;
            opts: {
                concurrency: number;
            };
        };
        prevStep: StepFlowEntry;
        prevOutput: any;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<StepResult<any, any, any, any>>;
    protected persistStepUpdate({ workflowId, runId, stepResults, serializedStepGraph, executionContext, workflowStatus, result, error, runtimeContext, }: {
        workflowId: string;
        runId: string;
        stepResults: Record<string, StepResult<any, any, any, any>>;
        serializedStepGraph: SerializedStepFlowEntry[];
        executionContext: ExecutionContext;
        workflowStatus: 'success' | 'failed' | 'suspended' | 'running' | 'waiting';
        result?: Record<string, any>;
        error?: string | Error;
        runtimeContext: RuntimeContext;
    }): Promise<void>;
    executeEntry({ workflowId, runId, entry, prevStep, serializedStepGraph, stepResults, resume, executionContext, emitter, abortController, runtimeContext, writableStream, }: {
        workflowId: string;
        runId: string;
        entry: StepFlowEntry;
        prevStep: StepFlowEntry;
        serializedStepGraph: SerializedStepFlowEntry[];
        stepResults: Record<string, StepResult<any, any, any, any>>;
        resume?: {
            steps: string[];
            stepResults: Record<string, StepResult<any, any, any, any>>;
            resumePayload: any;
            resumePath: number[];
        };
        executionContext: ExecutionContext;
        emitter: Emitter;
        abortController: AbortController;
        runtimeContext: RuntimeContext;
        writableStream?: WritableStream<ChunkType>;
    }): Promise<{
        result: StepResult<any, any, any, any>;
        stepResults?: Record<string, StepResult<any, any, any, any>>;
        executionContext?: ExecutionContext;
    }>;
}
//# sourceMappingURL=default.d.ts.map