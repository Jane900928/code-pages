import { z } from 'zod';
import type { LanguageModel } from '../llm/index.js';
import type { MastraLanguageModel } from '../memory/index.js';
import type { ScoringSamplingConfig } from './types.js';
interface ScorerStepDefinition {
    name: string;
    definition: any;
    isPromptObject: boolean;
}
interface ScorerConfig<TInput = any, TRunOutput = any> {
    name: string;
    description: string;
    judge?: {
        model: LanguageModel;
        instructions: string;
    };
}
interface ScorerRun<TInput = any, TOutput = any> {
    runId?: string;
    input?: TInput;
    output: TOutput;
    runtimeContext?: Record<string, any>;
}
interface PromptObject<TOutput, TAccumulated extends Record<string, any>, TStepName extends string = string, TInput = any, TRunOutput = any> {
    description: string;
    outputSchema: z.ZodSchema<TOutput>;
    judge?: {
        model: MastraLanguageModel;
        instructions: string;
    };
    createPrompt: (context: PromptObjectContext<TAccumulated, TStepName, TInput, TRunOutput>) => string | Promise<string>;
}
type StepResultKey<T extends string> = `${T}StepResult`;
type Awaited<T> = T extends Promise<infer U> ? U : T;
type StepContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = {
    run: ScorerRun<TInput, TRunOutput>;
    results: TAccumulated;
};
type AccumulatedResults<T extends Record<string, any>, K extends string, V> = T & Record<StepResultKey<K>, V>;
type GenerateReasonContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = StepContext<TAccumulated, TInput, TRunOutput> & {
    score: TAccumulated extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;
};
type ScorerRunResult<TAccumulatedResults extends Record<string, any>, TInput, TRunOutput> = Promise<ScorerRun<TInput, TRunOutput> & {
    score: TAccumulatedResults extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;
    reason?: TAccumulatedResults extends Record<'generateReasonStepResult', infer TReason> ? TReason : undefined;
    preprocessPrompt?: string;
    analyzePrompt?: string;
    generateScorePrompt?: string;
    generateReasonPrompt?: string;
    preprocessStepResult?: TAccumulatedResults extends Record<'preprocessStepResult', infer TPreprocess> ? TPreprocess : undefined;
    analyzeStepResult?: TAccumulatedResults extends Record<'analyzeStepResult', infer TAnalyze> ? TAnalyze : undefined;
} & {
    runId: string;
}>;
type PromptObjectContext<TAccumulated extends Record<string, any>, TStepName extends string, TInput, TRunOutput> = TStepName extends 'generateReason' ? GenerateReasonContext<TAccumulated, TInput, TRunOutput> : StepContext<TAccumulated, TInput, TRunOutput>;
type FunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput, TOutput> = ((context: StepContext<TAccumulated, TInput, TRunOutput>) => TOutput) | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<TOutput>);
type GenerateReasonFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> = ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => any) | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => Promise<any>);
type GenerateScoreFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> = ((context: StepContext<TAccumulated, TInput, TRunOutput>) => number) | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<number>);
interface GenerateScorePromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {
    description: string;
    judge?: {
        model: MastraLanguageModel;
        instructions: string;
    };
    createPrompt: (context: StepContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;
}
interface GenerateReasonPromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {
    description: string;
    judge?: {
        model: MastraLanguageModel;
        instructions: string;
    };
    createPrompt: (context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;
}
type PreprocessStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> = FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput> | PromptObject<TStepOutput, TAccumulated, 'preprocess', TInput, TRunOutput>;
type AnalyzeStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> = FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput> | PromptObject<TStepOutput, TAccumulated, 'analyze', TInput, TRunOutput>;
type GenerateScoreStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> = GenerateScoreFunctionStep<TAccumulated, TInput, TRunOutput> | GenerateScorePromptObject<TAccumulated, TInput, TRunOutput>;
type GenerateReasonStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> = GenerateReasonFunctionStep<TAccumulated, TInput, TRunOutput> | GenerateReasonPromptObject<TAccumulated, TInput, TRunOutput>;
declare class MastraScorer<TAccumulatedResults extends Record<string, any> = {}, TInput = any, TRunOutput = any> {
    config: ScorerConfig<TInput, TRunOutput>;
    private steps;
    private originalPromptObjects;
    constructor(config: ScorerConfig<TInput, TRunOutput>, steps?: Array<ScorerStepDefinition>, originalPromptObjects?: Map<string, PromptObject<any, any, any, TInput, TRunOutput> | GenerateReasonPromptObject<any, TInput, TRunOutput> | GenerateScorePromptObject<any, TInput, TRunOutput>>);
    get name(): string;
    get description(): string;
    get judge(): {
        model: LanguageModel;
        instructions: string;
    } | undefined;
    preprocess<TPreprocessOutput>(stepDef: PreprocessStepDef<TAccumulatedResults, TPreprocessOutput, TInput, TRunOutput>): MastraScorer<AccumulatedResults<TAccumulatedResults, 'preprocess', Awaited<TPreprocessOutput>>, TInput, TRunOutput>;
    analyze<TAnalyzeOutput>(stepDef: AnalyzeStepDef<TAccumulatedResults, TAnalyzeOutput, TInput, TRunOutput>): MastraScorer<AccumulatedResults<TAccumulatedResults, 'analyze', Awaited<TAnalyzeOutput>>, TInput, TRunOutput>;
    generateScore<TScoreOutput extends number = number>(stepDef: GenerateScoreStepDef<TAccumulatedResults, TInput, TRunOutput>): MastraScorer<AccumulatedResults<TAccumulatedResults, 'generateScore', Awaited<TScoreOutput>>, TInput, TRunOutput>;
    generateReason<TReasonOutput = string>(stepDef: GenerateReasonStepDef<TAccumulatedResults, TInput, TRunOutput>): MastraScorer<AccumulatedResults<TAccumulatedResults, 'generateReason', Awaited<TReasonOutput>>, TInput, TRunOutput>;
    private get hasGenerateScore();
    run(input: ScorerRun<TInput, TRunOutput>): ScorerRunResult<TAccumulatedResults, TInput, TRunOutput>;
    private isPromptObject;
    getSteps(): Array<{
        name: string;
        type: 'function' | 'prompt';
        description?: string;
    }>;
    private toMastraWorkflow;
    private createScorerContext;
    private executeFunctionStep;
    private executePromptStep;
    private transformToScorerResult;
}
export declare function createScorer<TInput = any, TRunOutput = any>({ name, description, judge, }: ScorerConfig<TInput, TRunOutput>): MastraScorer<{}, TInput, TRunOutput>;
export type MastraScorerEntry = {
    scorer: MastraScorer<any, any, any>;
    sampling?: ScoringSamplingConfig;
};
export type MastraScorers = Record<string, MastraScorerEntry>;
export type { ScorerConfig, ScorerRun, PromptObject };
export { MastraScorer };
//# sourceMappingURL=base.d.ts.map