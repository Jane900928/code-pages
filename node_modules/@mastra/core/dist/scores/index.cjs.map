{"version":3,"sources":["../../src/scores/types.ts","../../src/scores/base.ts"],"names":["z","MastraError","randomUUID","createStep","createWorkflow","Agent"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { CoreMessage, CoreSystemMessage } from 'ai';\nimport { z } from 'zod';\nimport type { UIMessageWithMetadata } from '../agent';\n\nexport type ScoringSamplingConfig = { type: 'none' } | { type: 'ratio'; rate: number };\n\nexport type ScoringSource = 'LIVE' | 'TEST';\n\nexport type ScoringEntityType = 'AGENT' | 'WORKFLOW';\n\nexport type ScoringPrompts = {\n  description: string;\n  prompt: string;\n};\n\nexport type ScoringInput = {\n  runId?: string;\n  input?: Record<string, any>[];\n  output: Record<string, any>;\n  additionalContext?: Record<string, any>;\n  runtimeContext?: Record<string, any>;\n};\n\nexport type ScoringHookInput = {\n  runId?: string;\n  scorer: Record<string, any>;\n  input: Record<string, any>[];\n  output: Record<string, any>;\n  metadata?: Record<string, any>;\n  additionalContext?: Record<string, any>;\n  source: ScoringSource;\n  entity: Record<string, any>;\n  entityType: ScoringEntityType;\n  runtimeContext?: Record<string, any>;\n  structuredOutput?: boolean;\n  traceId?: string;\n  resourceId?: string;\n  threadId?: string;\n};\n\nexport const scoringExtractStepResultSchema = z.record(z.string(), z.any()).optional();\n\nexport type ScoringExtractStepResult = z.infer<typeof scoringExtractStepResultSchema>;\n\nexport const scoringValueSchema = z.number();\n\nexport const scoreResultSchema = z.object({\n  result: z.record(z.string(), z.any()).optional(),\n  score: scoringValueSchema,\n  prompt: z.string().optional(),\n});\n\nexport type ScoringAnalyzeStepResult = z.infer<typeof scoreResultSchema>;\n\nexport type ScoringInputWithExtractStepResult<TExtract = any> = ScoringInput & {\n  runId: string;\n  extractStepResult?: TExtract;\n  extractPrompt?: string;\n};\n\nexport type ScoringInputWithExtractStepResultAndAnalyzeStepResult<\n  TExtract = any,\n  TScore = any,\n> = ScoringInputWithExtractStepResult<TExtract> & {\n  score: number;\n  analyzeStepResult?: TScore;\n  analyzePrompt?: string;\n};\n\nexport type ScoringInputWithExtractStepResultAndScoreAndReason =\n  ScoringInputWithExtractStepResultAndAnalyzeStepResult & {\n    reason?: string;\n    reasonPrompt?: string;\n  };\n\nexport type ScoreRowData = ScoringInputWithExtractStepResultAndScoreAndReason &\n  ScoringHookInput & {\n    id: string;\n    entityId: string;\n    scorerId: string;\n    createdAt: Date;\n    updatedAt: Date;\n    preprocessStepResult?: Record<string, any>;\n    preprocessPrompt?: string;\n    generateScorePrompt?: string;\n    generateReasonPrompt?: string;\n  };\n\nexport type ExtractionStepFn = (input: ScoringInput) => Promise<Record<string, any>>;\n\nexport type AnalyzeStepFn = (input: ScoringInputWithExtractStepResult) => Promise<ScoringAnalyzeStepResult>;\n\nexport type ReasonStepFn = (\n  input: ScoringInputWithExtractStepResultAndAnalyzeStepResult,\n) => Promise<{ reason: string; reasonPrompt?: string } | null>;\n\nexport type ScorerOptions = {\n  name: string;\n  description: string;\n  extract?: ExtractionStepFn;\n  analyze: AnalyzeStepFn;\n  reason?: ReasonStepFn;\n  metadata?: Record<string, any>;\n  isLLMScorer?: boolean;\n};\n\nexport type ScorerRunInputForAgent = {\n  inputMessages: UIMessageWithMetadata[];\n  rememberedMessages: UIMessageWithMetadata[];\n  systemMessages: CoreMessage[];\n  taggedSystemMessages: Record<string, CoreSystemMessage[]>;\n};\n\nexport type ScorerRunOutputForAgent = UIMessageWithMetadata[];\n","import { randomUUID } from 'crypto';\nimport { z } from 'zod';\nimport { Agent } from '../agent';\nimport { ErrorCategory, ErrorDomain, MastraError } from '../error';\nimport type { LanguageModel } from '../llm';\nimport type { MastraLanguageModel } from '../memory';\nimport { createWorkflow, createStep } from '../workflows';\nimport type { ScoringSamplingConfig } from './types';\n\ninterface ScorerStepDefinition {\n  name: string;\n  definition: any;\n  isPromptObject: boolean;\n}\n\n// Pipeline scorer\n// TInput and TRunOutput establish the type contract for the entire scorer pipeline,\n// ensuring type safety flows through all steps and contexts\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\ninterface ScorerConfig<TInput = any, TRunOutput = any> {\n  name: string;\n  description: string;\n  judge?: {\n    model: LanguageModel;\n    instructions: string;\n  };\n}\n\n// Standardized input type for all pipelines\ninterface ScorerRun<TInput = any, TOutput = any> {\n  runId?: string;\n  input?: TInput;\n  output: TOutput;\n  runtimeContext?: Record<string, any>;\n}\n\n// Prompt object definition with conditional typing\ninterface PromptObject<\n  TOutput,\n  TAccumulated extends Record<string, any>,\n  TStepName extends string = string,\n  TInput = any,\n  TRunOutput = any,\n> {\n  description: string;\n  outputSchema: z.ZodSchema<TOutput>;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n\n  // Support both sync and async createPrompt\n  createPrompt: (context: PromptObjectContext<TAccumulated, TStepName, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Helper types\ntype StepResultKey<T extends string> = `${T}StepResult`;\n\n// Simple utility type to extract resolved types from potentially async functions\ntype Awaited<T> = T extends Promise<infer U> ? U : T;\n\n// Simplified context type\ntype StepContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = {\n  run: ScorerRun<TInput, TRunOutput>;\n  results: TAccumulated;\n};\n\n// Simplified AccumulatedResults - don't try to resolve Promise types here\ntype AccumulatedResults<T extends Record<string, any>, K extends string, V> = T & Record<StepResultKey<K>, V>;\n\n// Special context type for generateReason that includes the score\ntype GenerateReasonContext<TAccumulated extends Record<string, any>, TInput, TRunOutput> = StepContext<\n  TAccumulated,\n  TInput,\n  TRunOutput\n> & {\n  score: TAccumulated extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;\n};\n\ntype ScorerRunResult<TAccumulatedResults extends Record<string, any>, TInput, TRunOutput> = Promise<\n  ScorerRun<TInput, TRunOutput> & {\n    score: TAccumulatedResults extends Record<'generateScoreStepResult', infer TScore> ? TScore : never;\n    reason?: TAccumulatedResults extends Record<'generateReasonStepResult', infer TReason> ? TReason : undefined;\n\n    // Prompts\n    preprocessPrompt?: string;\n    analyzePrompt?: string;\n    generateScorePrompt?: string;\n    generateReasonPrompt?: string;\n\n    // Results\n    preprocessStepResult?: TAccumulatedResults extends Record<'preprocessStepResult', infer TPreprocess>\n      ? TPreprocess\n      : undefined;\n    analyzeStepResult?: TAccumulatedResults extends Record<'analyzeStepResult', infer TAnalyze> ? TAnalyze : undefined;\n  } & { runId: string }\n>;\n\n// Conditional type for PromptObject context\ntype PromptObjectContext<\n  TAccumulated extends Record<string, any>,\n  TStepName extends string,\n  TInput,\n  TRunOutput,\n> = TStepName extends 'generateReason'\n  ? GenerateReasonContext<TAccumulated, TInput, TRunOutput>\n  : StepContext<TAccumulated, TInput, TRunOutput>;\n\n// Function step types that support both sync and async\ntype FunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput, TOutput> =\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => TOutput)\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<TOutput>);\n\ntype GenerateReasonFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => any)\n  | ((context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => Promise<any>);\n\ntype GenerateScoreFunctionStep<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => number)\n  | ((context: StepContext<TAccumulated, TInput, TRunOutput>) => Promise<number>);\n\n// Special prompt object type for generateScore that always returns a number\ninterface GenerateScorePromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {\n  description: string;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n  // Support both sync and async createPrompt\n  createPrompt: (context: StepContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Special prompt object type for generateReason that always returns a string\ninterface GenerateReasonPromptObject<TAccumulated extends Record<string, any>, TInput, TRunOutput> {\n  description: string;\n  judge?: {\n    model: MastraLanguageModel;\n    instructions: string;\n  };\n  // Support both sync and async createPrompt\n  createPrompt: (context: GenerateReasonContext<TAccumulated, TInput, TRunOutput>) => string | Promise<string>;\n}\n\n// Step definition types that support both function and prompt object steps\ntype PreprocessStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> =\n  | FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput>\n  | PromptObject<TStepOutput, TAccumulated, 'preprocess', TInput, TRunOutput>;\n\ntype AnalyzeStepDef<TAccumulated extends Record<string, any>, TStepOutput, TInput, TRunOutput> =\n  | FunctionStep<TAccumulated, TInput, TRunOutput, TStepOutput>\n  | PromptObject<TStepOutput, TAccumulated, 'analyze', TInput, TRunOutput>;\n\n// Conditional type for generateScore step definition\ntype GenerateScoreStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | GenerateScoreFunctionStep<TAccumulated, TInput, TRunOutput>\n  | GenerateScorePromptObject<TAccumulated, TInput, TRunOutput>;\n\n// Conditional type for generateReason step definition\ntype GenerateReasonStepDef<TAccumulated extends Record<string, any>, TInput, TRunOutput> =\n  | GenerateReasonFunctionStep<TAccumulated, TInput, TRunOutput>\n  | GenerateReasonPromptObject<TAccumulated, TInput, TRunOutput>;\n\nclass MastraScorer<TAccumulatedResults extends Record<string, any> = {}, TInput = any, TRunOutput = any> {\n  constructor(\n    public config: ScorerConfig<TInput, TRunOutput>,\n    private steps: Array<ScorerStepDefinition> = [],\n    private originalPromptObjects: Map<\n      string,\n      | PromptObject<any, any, any, TInput, TRunOutput>\n      | GenerateReasonPromptObject<any, TInput, TRunOutput>\n      | GenerateScorePromptObject<any, TInput, TRunOutput>\n    > = new Map(),\n  ) {}\n\n  get name(): string {\n    return this.config.name;\n  }\n\n  get description(): string {\n    return this.config.description;\n  }\n\n  get judge() {\n    return this.config.judge;\n  }\n\n  preprocess<TPreprocessOutput>(\n    stepDef: PreprocessStepDef<TAccumulatedResults, TPreprocessOutput, TInput, TRunOutput>,\n  ): MastraScorer<\n    AccumulatedResults<TAccumulatedResults, 'preprocess', Awaited<TPreprocessOutput>>,\n    TInput,\n    TRunOutput\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as PromptObject<\n        TPreprocessOutput,\n        TAccumulatedResults,\n        'preprocess',\n        TInput,\n        TRunOutput\n      >;\n      this.originalPromptObjects.set('preprocess', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'preprocess',\n          definition: stepDef as FunctionStep<any, TInput, TRunOutput, TPreprocessOutput>,\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  analyze<TAnalyzeOutput>(\n    stepDef: AnalyzeStepDef<TAccumulatedResults, TAnalyzeOutput, TInput, TRunOutput>,\n  ): MastraScorer<AccumulatedResults<TAccumulatedResults, 'analyze', Awaited<TAnalyzeOutput>>, TInput, TRunOutput> {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as PromptObject<TAnalyzeOutput, TAccumulatedResults, 'analyze', TInput, TRunOutput>;\n      this.originalPromptObjects.set('analyze', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'analyze',\n          definition: isPromptObj ? undefined : (stepDef as FunctionStep<any, TInput, TRunOutput, TAnalyzeOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  generateScore<TScoreOutput extends number = number>(\n    stepDef: GenerateScoreStepDef<TAccumulatedResults, TInput, TRunOutput>,\n  ): MastraScorer<AccumulatedResults<TAccumulatedResults, 'generateScore', Awaited<TScoreOutput>>, TInput, TRunOutput> {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as GenerateScorePromptObject<TAccumulatedResults, TInput, TRunOutput>;\n      this.originalPromptObjects.set('generateScore', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'generateScore',\n          definition: isPromptObj ? undefined : (stepDef as GenerateScoreFunctionStep<any, TInput, TRunOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  generateReason<TReasonOutput = string>(\n    stepDef: GenerateReasonStepDef<TAccumulatedResults, TInput, TRunOutput>,\n  ): MastraScorer<\n    AccumulatedResults<TAccumulatedResults, 'generateReason', Awaited<TReasonOutput>>,\n    TInput,\n    TRunOutput\n  > {\n    const isPromptObj = this.isPromptObject(stepDef);\n\n    if (isPromptObj) {\n      const promptObj = stepDef as GenerateReasonPromptObject<TAccumulatedResults, TInput, TRunOutput>;\n      this.originalPromptObjects.set('generateReason', promptObj);\n    }\n\n    return new MastraScorer(\n      this.config,\n      [\n        ...this.steps,\n        {\n          name: 'generateReason',\n          definition: isPromptObj ? undefined : (stepDef as GenerateReasonFunctionStep<any, TInput, TRunOutput>),\n          isPromptObject: isPromptObj,\n        },\n      ],\n      new Map(this.originalPromptObjects),\n    );\n  }\n\n  private get hasGenerateScore(): boolean {\n    return this.steps.some(step => step.name === 'generateScore');\n  }\n\n  async run(input: ScorerRun<TInput, TRunOutput>): ScorerRunResult<TAccumulatedResults, TInput, TRunOutput> {\n    // Runtime check: execute only allowed after generateScore\n    if (!this.hasGenerateScore) {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_MISSING_GENERATE_SCORE',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Cannot execute pipeline without generateScore() step`,\n        details: {\n          scorerId: this.config.name,\n          steps: this.steps.map(s => s.name).join(', '),\n        },\n      });\n    }\n\n    let runId = input.runId;\n    if (!runId) {\n      runId = randomUUID();\n    }\n\n    const run = { ...input, runId };\n\n    const workflow = this.toMastraWorkflow();\n    const workflowRun = await workflow.createRunAsync();\n    const workflowResult = await workflowRun.start({\n      inputData: {\n        run,\n      },\n    });\n\n    if (workflowResult.status === 'failed') {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_WORKFLOW_FAILED',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Scorer Run Failed: ${workflowResult.error}`,\n        details: {\n          scorerId: this.config.name,\n          steps: this.steps.map(s => s.name).join(', '),\n        },\n      });\n    }\n\n    return this.transformToScorerResult({ workflowResult, originalInput: run });\n  }\n\n  private isPromptObject(stepDef: any): boolean {\n    // Check if it's a generateScore prompt object (has description and createPrompt, but no outputSchema)\n    if (\n      typeof stepDef === 'object' &&\n      'description' in stepDef &&\n      'createPrompt' in stepDef &&\n      !('outputSchema' in stepDef)\n    ) {\n      return true;\n    }\n\n    // For other steps, check for description, outputSchema, and createPrompt\n    const isOtherPromptObject =\n      typeof stepDef === 'object' && 'description' in stepDef && 'outputSchema' in stepDef && 'createPrompt' in stepDef;\n\n    return isOtherPromptObject;\n  }\n\n  getSteps(): Array<{ name: string; type: 'function' | 'prompt'; description?: string }> {\n    return this.steps.map(step => ({\n      name: step.name,\n      type: step.isPromptObject ? 'prompt' : 'function',\n      description: step.definition.description,\n    }));\n  }\n\n  private toMastraWorkflow() {\n    // Convert each scorer step to a workflow step\n    const workflowSteps = this.steps.map(scorerStep => {\n      return createStep({\n        id: scorerStep.name,\n        description: `Scorer step: ${scorerStep.name}`,\n        inputSchema: z.any(),\n        outputSchema: z.any(),\n        execute: async ({ inputData, getInitData }) => {\n          const { accumulatedResults = {}, generatedPrompts = {} } = inputData;\n          const { run } = getInitData();\n\n          const context = this.createScorerContext(scorerStep.name, run, accumulatedResults);\n\n          let stepResult;\n          let newGeneratedPrompts = generatedPrompts;\n          if (scorerStep.isPromptObject) {\n            const { result, prompt } = await this.executePromptStep(scorerStep, context);\n            stepResult = result;\n            newGeneratedPrompts = {\n              ...generatedPrompts,\n              [`${scorerStep.name}Prompt`]: prompt,\n            };\n          } else {\n            stepResult = await this.executeFunctionStep(scorerStep, context);\n          }\n\n          const newAccumulatedResults = {\n            ...accumulatedResults,\n            [`${scorerStep.name}StepResult`]: stepResult,\n          };\n\n          return {\n            stepResult,\n            accumulatedResults: newAccumulatedResults,\n            generatedPrompts: newGeneratedPrompts,\n          };\n        },\n      });\n    });\n\n    const workflow = createWorkflow({\n      id: `scorer-${this.config.name}`,\n      description: this.config.description,\n      inputSchema: z.object({\n        run: z.any(), // ScorerRun\n      }),\n      outputSchema: z.object({\n        run: z.any(),\n        score: z.number(),\n        reason: z.string().optional(),\n        preprocessResult: z.any().optional(),\n        analyzeResult: z.any().optional(),\n        preprocessPrompt: z.string().optional(),\n        analyzePrompt: z.string().optional(),\n        generateScorePrompt: z.string().optional(),\n        generateReasonPrompt: z.string().optional(),\n      }),\n    });\n\n    let chainedWorkflow = workflow;\n    for (const step of workflowSteps) {\n      // @ts-ignore - Complain about the type mismatch when we chain the steps\n      chainedWorkflow = chainedWorkflow.then(step);\n    }\n\n    return chainedWorkflow.commit();\n  }\n\n  private createScorerContext(\n    stepName: string,\n    run: ScorerRun<TInput, TRunOutput>,\n    accumulatedResults: Record<string, any>,\n  ) {\n    if (stepName === 'generateReason') {\n      const score = accumulatedResults.generateScoreStepResult;\n      return { run, results: accumulatedResults, score };\n    }\n\n    return { run, results: accumulatedResults };\n  }\n\n  private async executeFunctionStep(scorerStep: ScorerStepDefinition, context: any) {\n    return await scorerStep.definition(context);\n  }\n\n  private async executePromptStep(scorerStep: ScorerStepDefinition, context: any) {\n    const originalStep = this.originalPromptObjects.get(scorerStep.name);\n    if (!originalStep) {\n      throw new Error(`Step \"${scorerStep.name}\" is not a prompt object`);\n    }\n\n    const prompt = await originalStep.createPrompt(context);\n    const model = originalStep.judge?.model ?? this.config.judge?.model;\n    const instructions = originalStep.judge?.instructions ?? this.config.judge?.instructions;\n\n    if (!model || !instructions) {\n      throw new MastraError({\n        id: 'MASTR_SCORER_FAILED_TO_RUN_MISSING_MODEL_OR_INSTRUCTIONS',\n        domain: ErrorDomain.SCORER,\n        category: ErrorCategory.USER,\n        text: `Step \"${scorerStep.name}\" requires a model and instructions`,\n        details: {\n          scorerId: this.config.name,\n          step: scorerStep.name,\n        },\n      });\n    }\n\n    const judge = new Agent({ name: 'judge', model, instructions });\n\n    // GenerateScore output must be a number\n    if (scorerStep.name === 'generateScore') {\n      const result = await judge.generate(prompt, {\n        output: z.object({ score: z.number() }),\n      });\n      return { result: result.object.score, prompt };\n\n      // GenerateReason output must be a string\n    } else if (scorerStep.name === 'generateReason') {\n      const result = await judge.generate(prompt);\n      return { result: result.text, prompt };\n    } else {\n      const promptStep = originalStep as PromptObject<any, any, any, TInput, TRunOutput>;\n      const result = await judge.generate(prompt, {\n        output: promptStep.outputSchema,\n      });\n      return { result: result.object, prompt };\n    }\n  }\n\n  private transformToScorerResult({\n    workflowResult,\n    originalInput,\n  }: {\n    workflowResult: any;\n    originalInput: ScorerRun<TInput, TRunOutput> & { runId: string };\n  }) {\n    const finalStepResult = workflowResult.result;\n    const accumulatedResults = finalStepResult?.accumulatedResults || {};\n    const generatedPrompts = finalStepResult?.generatedPrompts || {};\n\n    return {\n      ...originalInput,\n      score: accumulatedResults.generateScoreStepResult,\n      generateScorePrompt: generatedPrompts.generateScorePrompt,\n      reason: accumulatedResults.generateReasonStepResult,\n      generateReasonPrompt: generatedPrompts.generateReasonPrompt,\n      preprocessStepResult: accumulatedResults.preprocessStepResult,\n      preprocessPrompt: generatedPrompts.preprocessPrompt,\n      analyzeStepResult: accumulatedResults.analyzeStepResult,\n      analyzePrompt: generatedPrompts.analyzePrompt,\n    };\n  }\n}\n\nexport function createScorer<TInput = any, TRunOutput = any>({\n  name,\n  description,\n  judge,\n}: ScorerConfig<TInput, TRunOutput>): MastraScorer<{}, TInput, TRunOutput> {\n  return new MastraScorer<{}, TInput, TRunOutput>({ name, description, judge });\n}\n\nexport type MastraScorerEntry = {\n  scorer: MastraScorer<any, any, any>;\n  sampling?: ScoringSamplingConfig;\n};\n\nexport type MastraScorers = Record<string, MastraScorerEntry>;\n\n// Export types and interfaces for use in test files\nexport type { ScorerConfig, ScorerRun, PromptObject };\n\nexport { MastraScorer };\n"]}