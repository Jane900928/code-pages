import { createStep, createWorkflow } from '../chunk-MTRRRTB4.js';
import { Agent } from '../chunk-IL5SHDY4.js';
import { MastraError } from '../chunk-4O4YNORN.js';
import { z } from 'zod';
import { randomUUID } from 'crypto';

var scoringExtractStepResultSchema = z.record(z.string(), z.any()).optional();
var scoringValueSchema = z.number();
var scoreResultSchema = z.object({
  result: z.record(z.string(), z.any()).optional(),
  score: scoringValueSchema,
  prompt: z.string().optional()
});
var MastraScorer = class _MastraScorer {
  constructor(config, steps = [], originalPromptObjects = /* @__PURE__ */ new Map()) {
    this.config = config;
    this.steps = steps;
    this.originalPromptObjects = originalPromptObjects;
  }
  get name() {
    return this.config.name;
  }
  get description() {
    return this.config.description;
  }
  get judge() {
    return this.config.judge;
  }
  preprocess(stepDef) {
    const isPromptObj = this.isPromptObject(stepDef);
    if (isPromptObj) {
      const promptObj = stepDef;
      this.originalPromptObjects.set("preprocess", promptObj);
    }
    return new _MastraScorer(
      this.config,
      [
        ...this.steps,
        {
          name: "preprocess",
          definition: stepDef,
          isPromptObject: isPromptObj
        }
      ],
      new Map(this.originalPromptObjects)
    );
  }
  analyze(stepDef) {
    const isPromptObj = this.isPromptObject(stepDef);
    if (isPromptObj) {
      const promptObj = stepDef;
      this.originalPromptObjects.set("analyze", promptObj);
    }
    return new _MastraScorer(
      this.config,
      [
        ...this.steps,
        {
          name: "analyze",
          definition: isPromptObj ? void 0 : stepDef,
          isPromptObject: isPromptObj
        }
      ],
      new Map(this.originalPromptObjects)
    );
  }
  generateScore(stepDef) {
    const isPromptObj = this.isPromptObject(stepDef);
    if (isPromptObj) {
      const promptObj = stepDef;
      this.originalPromptObjects.set("generateScore", promptObj);
    }
    return new _MastraScorer(
      this.config,
      [
        ...this.steps,
        {
          name: "generateScore",
          definition: isPromptObj ? void 0 : stepDef,
          isPromptObject: isPromptObj
        }
      ],
      new Map(this.originalPromptObjects)
    );
  }
  generateReason(stepDef) {
    const isPromptObj = this.isPromptObject(stepDef);
    if (isPromptObj) {
      const promptObj = stepDef;
      this.originalPromptObjects.set("generateReason", promptObj);
    }
    return new _MastraScorer(
      this.config,
      [
        ...this.steps,
        {
          name: "generateReason",
          definition: isPromptObj ? void 0 : stepDef,
          isPromptObject: isPromptObj
        }
      ],
      new Map(this.originalPromptObjects)
    );
  }
  get hasGenerateScore() {
    return this.steps.some((step) => step.name === "generateScore");
  }
  async run(input) {
    if (!this.hasGenerateScore) {
      throw new MastraError({
        id: "MASTR_SCORER_FAILED_TO_RUN_MISSING_GENERATE_SCORE",
        domain: "SCORER" /* SCORER */,
        category: "USER" /* USER */,
        text: `Cannot execute pipeline without generateScore() step`,
        details: {
          scorerId: this.config.name,
          steps: this.steps.map((s) => s.name).join(", ")
        }
      });
    }
    let runId = input.runId;
    if (!runId) {
      runId = randomUUID();
    }
    const run = { ...input, runId };
    const workflow = this.toMastraWorkflow();
    const workflowRun = await workflow.createRunAsync();
    const workflowResult = await workflowRun.start({
      inputData: {
        run
      }
    });
    if (workflowResult.status === "failed") {
      throw new MastraError({
        id: "MASTR_SCORER_FAILED_TO_RUN_WORKFLOW_FAILED",
        domain: "SCORER" /* SCORER */,
        category: "USER" /* USER */,
        text: `Scorer Run Failed: ${workflowResult.error}`,
        details: {
          scorerId: this.config.name,
          steps: this.steps.map((s) => s.name).join(", ")
        }
      });
    }
    return this.transformToScorerResult({ workflowResult, originalInput: run });
  }
  isPromptObject(stepDef) {
    if (typeof stepDef === "object" && "description" in stepDef && "createPrompt" in stepDef && !("outputSchema" in stepDef)) {
      return true;
    }
    const isOtherPromptObject = typeof stepDef === "object" && "description" in stepDef && "outputSchema" in stepDef && "createPrompt" in stepDef;
    return isOtherPromptObject;
  }
  getSteps() {
    return this.steps.map((step) => ({
      name: step.name,
      type: step.isPromptObject ? "prompt" : "function",
      description: step.definition.description
    }));
  }
  toMastraWorkflow() {
    const workflowSteps = this.steps.map((scorerStep) => {
      return createStep({
        id: scorerStep.name,
        description: `Scorer step: ${scorerStep.name}`,
        inputSchema: z.any(),
        outputSchema: z.any(),
        execute: async ({ inputData, getInitData }) => {
          const { accumulatedResults = {}, generatedPrompts = {} } = inputData;
          const { run } = getInitData();
          const context = this.createScorerContext(scorerStep.name, run, accumulatedResults);
          let stepResult;
          let newGeneratedPrompts = generatedPrompts;
          if (scorerStep.isPromptObject) {
            const { result, prompt } = await this.executePromptStep(scorerStep, context);
            stepResult = result;
            newGeneratedPrompts = {
              ...generatedPrompts,
              [`${scorerStep.name}Prompt`]: prompt
            };
          } else {
            stepResult = await this.executeFunctionStep(scorerStep, context);
          }
          const newAccumulatedResults = {
            ...accumulatedResults,
            [`${scorerStep.name}StepResult`]: stepResult
          };
          return {
            stepResult,
            accumulatedResults: newAccumulatedResults,
            generatedPrompts: newGeneratedPrompts
          };
        }
      });
    });
    const workflow = createWorkflow({
      id: `scorer-${this.config.name}`,
      description: this.config.description,
      inputSchema: z.object({
        run: z.any()
        // ScorerRun
      }),
      outputSchema: z.object({
        run: z.any(),
        score: z.number(),
        reason: z.string().optional(),
        preprocessResult: z.any().optional(),
        analyzeResult: z.any().optional(),
        preprocessPrompt: z.string().optional(),
        analyzePrompt: z.string().optional(),
        generateScorePrompt: z.string().optional(),
        generateReasonPrompt: z.string().optional()
      })
    });
    let chainedWorkflow = workflow;
    for (const step of workflowSteps) {
      chainedWorkflow = chainedWorkflow.then(step);
    }
    return chainedWorkflow.commit();
  }
  createScorerContext(stepName, run, accumulatedResults) {
    if (stepName === "generateReason") {
      const score = accumulatedResults.generateScoreStepResult;
      return { run, results: accumulatedResults, score };
    }
    return { run, results: accumulatedResults };
  }
  async executeFunctionStep(scorerStep, context) {
    return await scorerStep.definition(context);
  }
  async executePromptStep(scorerStep, context) {
    const originalStep = this.originalPromptObjects.get(scorerStep.name);
    if (!originalStep) {
      throw new Error(`Step "${scorerStep.name}" is not a prompt object`);
    }
    const prompt = await originalStep.createPrompt(context);
    const model = originalStep.judge?.model ?? this.config.judge?.model;
    const instructions = originalStep.judge?.instructions ?? this.config.judge?.instructions;
    if (!model || !instructions) {
      throw new MastraError({
        id: "MASTR_SCORER_FAILED_TO_RUN_MISSING_MODEL_OR_INSTRUCTIONS",
        domain: "SCORER" /* SCORER */,
        category: "USER" /* USER */,
        text: `Step "${scorerStep.name}" requires a model and instructions`,
        details: {
          scorerId: this.config.name,
          step: scorerStep.name
        }
      });
    }
    const judge = new Agent({ name: "judge", model, instructions });
    if (scorerStep.name === "generateScore") {
      const result = await judge.generate(prompt, {
        output: z.object({ score: z.number() })
      });
      return { result: result.object.score, prompt };
    } else if (scorerStep.name === "generateReason") {
      const result = await judge.generate(prompt);
      return { result: result.text, prompt };
    } else {
      const promptStep = originalStep;
      const result = await judge.generate(prompt, {
        output: promptStep.outputSchema
      });
      return { result: result.object, prompt };
    }
  }
  transformToScorerResult({
    workflowResult,
    originalInput
  }) {
    const finalStepResult = workflowResult.result;
    const accumulatedResults = finalStepResult?.accumulatedResults || {};
    const generatedPrompts = finalStepResult?.generatedPrompts || {};
    return {
      ...originalInput,
      score: accumulatedResults.generateScoreStepResult,
      generateScorePrompt: generatedPrompts.generateScorePrompt,
      reason: accumulatedResults.generateReasonStepResult,
      generateReasonPrompt: generatedPrompts.generateReasonPrompt,
      preprocessStepResult: accumulatedResults.preprocessStepResult,
      preprocessPrompt: generatedPrompts.preprocessPrompt,
      analyzeStepResult: accumulatedResults.analyzeStepResult,
      analyzePrompt: generatedPrompts.analyzePrompt
    };
  }
};
function createScorer({
  name,
  description,
  judge
}) {
  return new MastraScorer({ name, description, judge });
}

export { MastraScorer, createScorer, scoreResultSchema, scoringExtractStepResultSchema, scoringValueSchema };
//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map