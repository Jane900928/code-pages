{"version":3,"sources":["../../src/ai-tracing/no-op.ts","../../src/ai-tracing/types.ts","../../src/ai-tracing/base.ts","../../src/ai-tracing/default.ts","../../src/ai-tracing/registry.ts"],"names":["AISpanType","SamplingStrategyType","AITracingEventType"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * No Op Implementation for MastraAITracing\n */\n\nimport type { MastraAITracing } from './base';\nimport type { AISpanType, AISpan, AISpanOptions, AISpanTypeMap } from './types';\n\nexport class NoOpAISpan<TType extends AISpanType = any> implements AISpan<TType> {\n  public id: string;\n  public name: string;\n  public type: TType;\n  public metadata: AISpanTypeMap[TType];\n  public trace: AISpan<any>;\n  public traceId: string;\n  public startTime: Date;\n  public endTime?: Date;\n  public aiTracing: MastraAITracing;\n\n  constructor(options: AISpanOptions<TType>, aiTracing: MastraAITracing) {\n    this.id = 'no-op';\n    this.name = options.name;\n    this.type = options.type;\n    this.metadata = options.metadata;\n    this.trace = options.parent ? options.parent.trace : (this as any);\n    this.traceId = 'no-op-trace';\n    this.startTime = new Date();\n    this.aiTracing = aiTracing;\n  }\n\n  end(): void {}\n  error(): void {}\n  createChildSpan<TChildType extends AISpanType>(\n    type: TChildType,\n    name: string,\n    metadata: AISpanTypeMap[TChildType],\n  ): AISpan<TChildType> {\n    return new NoOpAISpan<TChildType>({ type, name, metadata, parent: this }, this.aiTracing);\n  }\n  update(): void {}\n}\n","/**\n * AI Tracing interfaces\n */\n\nimport type { MastraError } from '../error';\nimport type { RuntimeContext } from '../runtime-context';\nimport type { WorkflowRunStatus, WorkflowStepStatus } from '../workflows';\nimport type { MastraAITracing } from './base';\n\n// ============================================================================\n// Core AI-Specific Span Types\n// ============================================================================\n\n/**\n * AI-specific span types with their associated metadata\n */\nexport enum AISpanType {\n  /** Agent run - root span for agent processes */\n  AGENT_RUN = 'agent_run',\n  /** Generic span for custom operations */\n  GENERIC = 'generic',\n  /** LLM generation with model calls, token usage, prompts, completions */\n  LLM_GENERATION = 'llm_generation',\n  /** MCP (Model Context Protocol) tool execution */\n  MCP_TOOL_CALL = 'mcp_tool_call',\n  /** Function/tool execution with inputs, outputs, errors */\n  TOOL_CALL = 'tool_call',\n  /** Workflow run - root span for workflow processes */\n  WORKFLOW_RUN = 'workflow_run',\n  /** Workflow step execution with step status, data flow */\n  WORKFLOW_STEP = 'workflow_step',\n}\n\n// ============================================================================\n// Type-Specific Metadata Interfaces\n// ============================================================================\n\n/**\n * Base metadata that all spans can have\n */\nexport interface AIBaseMetadata {\n  /** Input passed at the start of the span */\n  input?: any;\n  /** Output generated at the end of the span */\n  output?: any;\n\n  /** Error information if span failed */\n  error?: {\n    message: string;\n    id?: string;\n    domain?: string;\n    category?: string;\n    details?: Record<string, any>;\n  };\n\n  /** Custom tags for categorization */\n  tags?: string[];\n  /** User-defined attributes */\n  attributes?: Record<string, any>;\n}\n\n/**\n * Agent Run metadata\n */\nexport interface AgentRunMetadata extends AIBaseMetadata {\n  /** Agent identifier */\n  agentId: string;\n  /** Agent Instructions **/\n  instructions?: string;\n  /** Agent Prompt **/\n  prompt?: string;\n  /** Available tools for this execution */\n  availableTools?: string[];\n  /** Maximum steps allowed */\n  maxSteps?: number;\n}\n\n/**\n * LLM Generation metadata\n */\nexport interface LLMGenerationMetadata extends AIBaseMetadata {\n  /** Model name (e.g., 'gpt-4', 'claude-3') */\n  model?: string;\n  /** Model provider (e.g., 'openai', 'anthropic') */\n  provider?: string;\n  /** Type of result/output this LLM call produced */\n  resultType?: 'tool_selection' | 'response_generation' | 'reasoning' | 'planning';\n  /** Token usage statistics */\n  usage?: {\n    promptTokens?: number;\n    completionTokens?: number;\n    totalTokens?: number;\n    promptCacheHitTokens?: number;\n    promptCacheMissTokens?: number;\n  };\n  /** Model parameters */\n  parameters?: {\n    temperature?: number;\n    maxTokens?: number;\n    topP?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n    stop?: string[];\n  };\n  /** Whether this was a streaming response */\n  streaming?: boolean;\n}\n\n/**\n * Tool Call metadata\n */\nexport interface ToolCallMetadata extends AIBaseMetadata {\n  toolId?: string;\n  success?: boolean;\n}\n\n/**\n * MCP Tool Call metadata\n */\nexport interface MCPToolCallMetadata extends AIBaseMetadata {\n  /** Id of the MCP tool/function */\n  toolId: string;\n  /** MCP server identifier */\n  mcpServer: string;\n  /** MCP server version */\n  serverVersion?: string;\n  /** Whether tool execution was successful */\n  success?: boolean;\n}\n\n/**\n * Workflow Run metadata\n */\nexport interface WorkflowRunMetadata extends AIBaseMetadata {\n  /** Workflow identifier */\n  workflowId: string;\n  /** Workflow status */\n  status?: WorkflowRunStatus;\n}\n\n/**\n * Workflow Step metadata\n */\nexport interface WorkflowStepMetadata extends AIBaseMetadata {\n  /** Step identifier */\n  stepId: string;\n  /** Step status */\n  status?: WorkflowStepStatus;\n}\n\n/**\n * AI-specific span types mapped to their metadata\n */\nexport interface AISpanTypeMap {\n  [AISpanType.AGENT_RUN]: AgentRunMetadata;\n  [AISpanType.WORKFLOW_RUN]: WorkflowRunMetadata;\n  [AISpanType.LLM_GENERATION]: LLMGenerationMetadata;\n  [AISpanType.TOOL_CALL]: ToolCallMetadata;\n  [AISpanType.MCP_TOOL_CALL]: MCPToolCallMetadata;\n  [AISpanType.WORKFLOW_STEP]: WorkflowStepMetadata;\n  [AISpanType.GENERIC]: AIBaseMetadata;\n}\n\n/**\n * Union type for cases that need to handle any span type\n */\nexport type AnyAISpanMetadata = AISpanTypeMap[keyof AISpanTypeMap];\n\n// ============================================================================\n// Span Interfaces\n// ============================================================================\n\n/**\n * AI Span interface with type safety\n */\nexport interface AISpan<TType extends AISpanType> {\n  /** Unique span identifier */\n  id: string;\n  /** Name of the span */\n  name: string;\n  /** Type of the span */\n  type: TType;\n  /** When span started */\n  startTime: Date;\n  /** When span ended */\n  endTime?: Date;\n  /** AI-specific metadata - strongly typed based on span type */\n  metadata: AISpanTypeMap[TType];\n  /** The top-level span - can be any type */\n  trace: AnyAISpan;\n  /** OpenTelemetry-compatible trace ID (32 hex chars) - present on all spans */\n  traceId: string;\n  /** Pointer to the AITracing instance */\n  aiTracing: MastraAITracing;\n\n  // Methods for span lifecycle\n  /** End the span */\n  end(metadata?: Partial<AISpanTypeMap[TType]>): void;\n\n  /** Record an error for the span, optionally end the span as well */\n  error(error: MastraError | Error, endSpan?: boolean): void;\n\n  /** Update span metadata */\n  update(metadata: Partial<AISpanTypeMap[TType]>): void;\n\n  /** Create child span - can be any span type independent of parent */\n  createChildSpan<TChildType extends AISpanType>(\n    type: TChildType,\n    name: string,\n    metadata: AISpanTypeMap[TChildType],\n  ): AISpan<TChildType>;\n}\n\n/**\n * Union type for cases that need to handle any span\n */\nexport type AnyAISpan = AISpan<keyof AISpanTypeMap>;\n\n/**\n * Options for span creation\n */\nexport interface AISpanOptions<TType extends AISpanType> {\n  /** Span name */\n  name: string;\n  /** Span type */\n  type: TType;\n  /** Span metadata */\n  metadata: AISpanTypeMap[TType];\n  /** Parent span */\n  parent?: AISpan<any>;\n}\n\n// ============================================================================\n// Configuration Types\n// ============================================================================\n\n/**\n * Sampling strategy types\n */\nexport enum SamplingStrategyType {\n  ALWAYS = 'always',\n  NEVER = 'never',\n  RATIO = 'ratio',\n  CUSTOM = 'custom',\n}\n\n/**\n * Context for TraceSampling\n */\nexport interface AITraceContext {\n  runtimeContext?: RuntimeContext;\n  attributes?: Record<string, any>;\n}\n\n/**\n * Sampling strategy configuration\n */\nexport type SamplingStrategy =\n  | { type: SamplingStrategyType.ALWAYS }\n  | { type: SamplingStrategyType.NEVER }\n  | { type: SamplingStrategyType.RATIO; probability: number }\n  | { type: SamplingStrategyType.CUSTOM; sampler: (traceContext: AITraceContext) => boolean };\n\n/**\n * Complete AI Tracing configuration that combines all options\n */\nexport interface AITracingConfig {\n  /** Service name for tracing */\n  serviceName: string;\n  /** Sampling strategy - controls whether tracing is collected */\n  sampling: SamplingStrategy;\n  /** Custom exporters */\n  exporters?: AITracingExporter[];\n  /** Custom processors */\n  processors?: AISpanProcessor[];\n}\n\n// ============================================================================\n// Exporter and Processor Interfaces\n// ============================================================================\n\n/**\n * AI Tracing event types\n */\nexport enum AITracingEventType {\n  SPAN_STARTED = 'span_started',\n  SPAN_UPDATED = 'span_updated',\n  SPAN_ENDED = 'span_ended',\n}\n\n/**\n * Tracing events that can be exported\n */\nexport type AITracingEvent =\n  | { type: AITracingEventType.SPAN_STARTED; span: AnyAISpan }\n  | { type: AITracingEventType.SPAN_UPDATED; span: AnyAISpan }\n  | { type: AITracingEventType.SPAN_ENDED; span: AnyAISpan };\n\n/**\n * Interface for tracing exporters\n */\nexport interface AITracingExporter {\n  /** Exporter name */\n  name: string;\n\n  /** Export tracing events */\n  exportEvent(event: AITracingEvent): Promise<void>;\n\n  /** Shutdown exporter */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Interface for span processors\n */\nexport interface AISpanProcessor {\n  /** Processor name */\n  name: string;\n  /** Process span before export */\n  process(span: AnyAISpan): AnyAISpan | null;\n  /** Shutdown processor */\n  shutdown(): Promise<void>;\n}\n","/**\n * MastraAITracing - Abstract base class for AI Tracing implementations\n */\n\nimport { MastraBase } from '../base';\nimport { RegisteredLogger } from '../logger/constants';\nimport type { RuntimeContext } from '../runtime-context';\nimport { NoOpAISpan } from './no-op';\nimport type {\n  AITracingConfig,\n  AISpan,\n  AISpanOptions,\n  AISpanType,\n  AITracingExporter,\n  AISpanProcessor,\n  AITracingEvent,\n  AITraceContext,\n  AISpanTypeMap,\n  AnyAISpan,\n} from './types';\nimport { SamplingStrategyType, AITracingEventType } from './types';\n\n// ============================================================================\n// Abstract Base Class\n// ============================================================================\n\n/**\n * Abstract base class for all AI Tracing implementations in Mastra.\n *\n */\nexport abstract class MastraAITracing extends MastraBase {\n  protected config: AITracingConfig;\n\n  constructor(config: AITracingConfig) {\n    super({ component: RegisteredLogger.AI_TELEMETRY, name: config.serviceName });\n\n    this.config = config;\n\n    this.logger.debug(`AI Tracing initialized [service=${config.serviceName}] [sampling=${this.config.sampling.type}]`);\n  }\n\n  // ============================================================================\n  // Protected getters for clean config access\n  // ============================================================================\n\n  protected get exporters(): AITracingExporter[] {\n    return this.config.exporters || [];\n  }\n\n  protected get processors(): AISpanProcessor[] {\n    return this.config.processors || [];\n  }\n\n  // ============================================================================\n  // Public API - Single type-safe span creation method\n  // ============================================================================\n\n  /**\n   * Start a new span of a specific AISpanType\n   */\n  startSpan<TType extends AISpanType>(\n    type: TType,\n    name: string,\n    metadata: AISpanTypeMap[TType],\n    parent?: AnyAISpan,\n    runtimeContext?: RuntimeContext,\n    attributes?: Record<string, any>,\n  ): AISpan<TType> {\n    if (!this.shouldSample({ runtimeContext, attributes })) {\n      return new NoOpAISpan<TType>({ type, name, metadata, parent }, this);\n    }\n\n    const options: AISpanOptions<TType> = {\n      type,\n      name,\n      metadata,\n      parent,\n    };\n\n    const span = this.createSpan(options);\n    span.trace = parent ? parent.trace : span;\n\n    // Automatically wire up tracing lifecycle\n    this.wireSpanLifecycle(span);\n\n    // Emit span started event\n    this.emitSpanStarted(span);\n\n    return span;\n  }\n\n  // ============================================================================\n  // Abstract Methods - Must be implemented by concrete classes\n  // ============================================================================\n\n  /**\n   * Create a new span (called after sampling)\n   *\n   * Implementations should:\n   * 1. Create a plain span with the provided metadata\n   * 2. Return the span - base class handles all tracing lifecycle automatically\n   *\n   * The base class will automatically:\n   * - Set trace relationships\n   * - Wire span lifecycle callbacks\n   * - Emit span_started event\n   */\n  protected abstract createSpan<TType extends AISpanType>(options: AISpanOptions<TType>): AISpan<TType>;\n\n  // ============================================================================\n  // Configuration Management\n  // ============================================================================\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): Readonly<AITracingConfig> {\n    return { ...this.config };\n  }\n\n  // ============================================================================\n  // Plugin Access\n  // ============================================================================\n\n  /**\n   * Get all exporters\n   */\n  getExporters(): readonly AITracingExporter[] {\n    return [...this.exporters];\n  }\n\n  /**\n   * Get all processors\n   */\n  getProcessors(): readonly AISpanProcessor[] {\n    return [...this.processors];\n  }\n\n  /**\n   * Get the logger instance (for exporters and other components)\n   */\n  getLogger() {\n    return this.logger;\n  }\n\n  // ============================================================================\n  // Span Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Automatically wires up AI tracing lifecycle events for any span\n   * This ensures all spans emit events regardless of implementation\n   */\n  private wireSpanLifecycle<TType extends AISpanType>(span: AISpan<TType>): void {\n    // Store original methods\n    const originalEnd = span.end.bind(span);\n    const originalUpdate = span.update.bind(span);\n\n    // Wrap methods to automatically emit tracing events\n    span.end = (metadata?: Partial<AISpanTypeMap[TType]>) => {\n      originalEnd(metadata);\n      this.emitSpanEnded(span);\n    };\n\n    span.update = (metadata: Partial<AISpanTypeMap[TType]>) => {\n      originalUpdate(metadata);\n      this.emitSpanUpdated(span);\n    };\n  }\n\n  // ============================================================================\n  // Utility Methods\n  // ============================================================================\n\n  /**\n   * Check if an AI trace should be sampled\n   */\n  protected shouldSample(traceContext: AITraceContext): boolean {\n    // Check built-in sampling strategy\n    const { sampling } = this.config;\n\n    switch (sampling.type) {\n      case SamplingStrategyType.ALWAYS:\n        return true;\n      case SamplingStrategyType.NEVER:\n        return false;\n      case SamplingStrategyType.RATIO:\n        if (sampling.probability === undefined || sampling.probability < 0 || sampling.probability > 1) {\n          this.logger.warn(\n            `Invalid sampling probability: ${sampling.probability}. Expected value between 0 and 1. Defaulting to no sampling.`,\n          );\n          return false;\n        }\n        return Math.random() < sampling.probability;\n      case SamplingStrategyType.CUSTOM:\n        return sampling.sampler(traceContext);\n      default:\n        throw new Error(`Sampling strategy type not implemented: ${(sampling as any).type}`);\n    }\n  }\n\n  /**\n   * Process a span through all processors\n   */\n  private processSpan(span: AnyAISpan): AnyAISpan | null {\n    let processedSpan: AnyAISpan | null = span;\n\n    for (const processor of this.processors) {\n      if (!processedSpan) {\n        break;\n      }\n\n      try {\n        processedSpan = processor.process(processedSpan);\n      } catch (error) {\n        this.logger.error(`Processor error [name=${processor.name}]`, error);\n        // Continue with other processors\n      }\n    }\n\n    return processedSpan;\n  }\n\n  // ============================================================================\n  // Event-driven Export Methods\n  // ============================================================================\n\n  /**\n   * Emit a span started event\n   */\n  protected emitSpanStarted(span: AnyAISpan): void {\n    // Process the span before emitting\n    const processedSpan = this.processSpan(span);\n    if (processedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_STARTED, span: processedSpan }).catch(error => {\n        this.logger.error('Failed to export span_started event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span ended event (called automatically when spans end)\n   */\n  protected emitSpanEnded(span: AnyAISpan): void {\n    // Process the span through all processors\n    const processedSpan = this.processSpan(span);\n    if (processedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_ENDED, span: processedSpan }).catch(error => {\n        this.logger.error('Failed to export span_ended event', error);\n      });\n    }\n  }\n\n  /**\n   * Emit a span updated event\n   */\n  protected emitSpanUpdated(span: AnyAISpan): void {\n    // Process the span before emitting\n    const processedSpan = this.processSpan(span);\n    if (processedSpan) {\n      this.exportEvent({ type: AITracingEventType.SPAN_UPDATED, span: processedSpan }).catch(error => {\n        this.logger.error('Failed to export span_updated event', error);\n      });\n    }\n  }\n\n  /**\n   * Export tracing event through all exporters (realtime mode)\n   */\n  protected async exportEvent(event: AITracingEvent): Promise<void> {\n    const exportPromises = this.exporters.map(async exporter => {\n      try {\n        if (exporter.exportEvent) {\n          await exporter.exportEvent(event);\n          this.logger.debug(`Event exported [exporter=${exporter.name}] [type=${event.type}]`);\n        }\n      } catch (error) {\n        this.logger.error(`Export error [exporter=${exporter.name}]`, error);\n        // Don't rethrow - continue with other exporters\n      }\n    });\n\n    await Promise.allSettled(exportPromises);\n  }\n\n  // ============================================================================\n  // Lifecycle Management\n  // ============================================================================\n\n  /**\n   * Initialize AI tracing (called by Mastra during component registration)\n   */\n  async init(): Promise<void> {\n    this.logger.debug(`AI Tracing initialization started [name=${this.name}]`);\n\n    // Any initialization logic for the AI tracing system\n    // This could include setting up queues, starting background processes, etc.\n\n    this.logger.info(`AI Tracing initialized successfully [name=${this.name}]`);\n  }\n\n  /**\n   * Shutdown AI tracing and clean up resources\n   */\n  async shutdown(): Promise<void> {\n    this.logger.debug(`AI Tracing shutdown started [name=${this.name}]`);\n\n    // Shutdown all components\n    const shutdownPromises = [...this.exporters.map(e => e.shutdown()), ...this.processors.map(p => p.shutdown())];\n\n    await Promise.allSettled(shutdownPromises);\n\n    this.logger.info(`AI Tracing shutdown completed [name=${this.name}]`);\n  }\n}\n","/**\n * Default Implementation for MastraAITracing\n */\n\nimport { MastraError } from '../error';\nimport type { IMastraLogger } from '../logger';\nimport { ConsoleLogger } from '../logger';\nimport { MastraAITracing } from './base';\nimport type {\n  AISpanType,\n  AISpan,\n  AISpanOptions,\n  AITracingExporter,\n  AITracingConfig,\n  AITracingEvent,\n  AISpanTypeMap,\n  AISpanProcessor,\n  AnyAISpan,\n} from './types';\nimport { SamplingStrategyType, AITracingEventType } from './types';\n\n// ============================================================================\n// Default AISpan Implementation\n// ============================================================================\n\n/**\n * Generate OpenTelemetry-compatible span ID (64-bit, 16 hex chars)\n */\nfunction generateSpanId(): string {\n  // Generate 8 random bytes (64 bits) in hex format\n  const bytes = new Uint8Array(8);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 8; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\n/**\n * Generate OpenTelemetry-compatible trace ID (128-bit, 32 hex chars)\n */\nfunction generateTraceId(): string {\n  // Generate 16 random bytes (128 bits) in hex format\n  const bytes = new Uint8Array(16);\n  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {\n    crypto.getRandomValues(bytes);\n  } else {\n    // Fallback for environments without crypto.getRandomValues\n    for (let i = 0; i < 16; i++) {\n      bytes[i] = Math.floor(Math.random() * 256);\n    }\n  }\n  return Array.from(bytes, byte => byte.toString(16).padStart(2, '0')).join('');\n}\n\nclass DefaultAISpan<TType extends AISpanType> implements AISpan<TType> {\n  public id: string;\n  public name: string;\n  public type: TType;\n  public metadata: AISpanTypeMap[TType];\n  public trace: AISpan<any>;\n  public traceId: string;\n  public startTime: Date;\n  public endTime?: Date;\n  public aiTracing: MastraAITracing;\n\n  constructor(options: AISpanOptions<TType>, aiTracing: MastraAITracing) {\n    this.id = generateSpanId();\n    this.name = options.name;\n    this.type = options.type;\n    this.metadata = options.metadata;\n    this.trace = options.parent ? options.parent.trace : (this as any);\n    this.startTime = new Date();\n    this.aiTracing = aiTracing;\n\n    // Set trace ID: generate new for root spans, inherit for child spans\n    if (!options.parent) {\n      // This is a root span, so it becomes its own trace with a new trace ID\n      this.traceId = generateTraceId();\n    } else {\n      // Child span inherits trace ID from root span\n      this.traceId = options.parent.trace.traceId;\n    }\n  }\n\n  end(metadata?: Partial<AISpanTypeMap[TType]>): void {\n    this.endTime = new Date();\n    if (metadata) {\n      this.metadata = { ...this.metadata, ...metadata };\n    }\n    // Tracing events automatically handled by base class\n  }\n\n  error(error: MastraError | Error, endSpan: boolean = true): void {\n    const errorMetadata =\n      error instanceof MastraError\n        ? {\n            error: {\n              id: error.id,\n              details: error.details,\n              category: error.category,\n              domain: error.domain,\n              message: error.message,\n            },\n          }\n        : {\n            error: {\n              message: error.message,\n            },\n          };\n\n    if (endSpan) {\n      this.end(errorMetadata as Partial<AISpanTypeMap[TType]>);\n    } else {\n      this.update(errorMetadata as Partial<AISpanTypeMap[TType]>);\n    }\n  }\n\n  createChildSpan<TChildType extends AISpanType>(\n    type: TChildType,\n    name: string,\n    metadata: AISpanTypeMap[TChildType],\n  ): AISpan<TChildType> {\n    return this.aiTracing.startSpan(type, name, metadata, this);\n  }\n\n  update(metadata: Partial<AISpanTypeMap[TType]>): void {\n    this.metadata = { ...this.metadata, ...metadata };\n    // Tracing events automatically handled by base class\n  }\n\n  async export(): Promise<string> {\n    return JSON.stringify({\n      id: this.id,\n      metadata: this.metadata,\n      startTime: this.startTime,\n      endTime: this.endTime,\n      traceId: this.traceId, // OpenTelemetry trace ID\n    });\n  }\n}\n\n// ============================================================================\n// Sensitive Data Filter Processor\n// ============================================================================\n\nexport class SensitiveDataFilter implements AISpanProcessor {\n  name = 'sensitive-data-filter';\n  private sensitiveFields: string[];\n\n  constructor(sensitiveFields?: string[]) {\n    // Default sensitive fields with case-insensitive matching\n    this.sensitiveFields = (\n      sensitiveFields || [\n        'password',\n        'token',\n        'secret',\n        'key',\n        'apiKey',\n        'auth',\n        'authorization',\n        'bearer',\n        'jwt',\n        'credential',\n        'sessionId',\n      ]\n    ).map(field => field.toLowerCase());\n  }\n\n  process(span: AnyAISpan): AnyAISpan | null {\n    // Deep filter function to recursively handle nested objects\n    const deepFilter = (obj: any, seen = new WeakSet()): any => {\n      if (obj === null || typeof obj !== 'object') {\n        return obj;\n      }\n\n      // Handle circular references\n      if (seen.has(obj)) {\n        return '[Circular Reference]';\n      }\n      seen.add(obj);\n\n      if (Array.isArray(obj)) {\n        return obj.map(item => deepFilter(item, seen));\n      }\n\n      const filtered: any = {};\n      Object.keys(obj).forEach(key => {\n        if (this.sensitiveFields.includes(key.toLowerCase())) {\n          // Only redact primitive values, recurse into objects/arrays\n          if (obj[key] && typeof obj[key] === 'object') {\n            filtered[key] = deepFilter(obj[key], seen);\n          } else {\n            filtered[key] = '[REDACTED]';\n          }\n        } else {\n          filtered[key] = deepFilter(obj[key], seen);\n        }\n      });\n\n      return filtered;\n    };\n\n    try {\n      // Create a copy of the span with filtered metadata\n      const filteredSpan = { ...span };\n      filteredSpan.metadata = deepFilter(span.metadata);\n      return filteredSpan;\n    } catch (error) {\n      // If filtering fails, return heavily redacted span for security\n      const safeSpan = { ...span };\n      safeSpan.metadata = {\n        '[FILTERING_ERROR]': 'Metadata was completely redacted due to filtering error',\n        '[ERROR_MESSAGE]': error instanceof Error ? error.message : 'Unknown filtering error',\n      } as any;\n      return safeSpan;\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    // No cleanup needed\n  }\n}\n\n// ============================================================================\n// Default Console Exporter\n// ============================================================================\n\nexport class DefaultConsoleExporter implements AITracingExporter {\n  name = 'default-console';\n  private logger: IMastraLogger;\n\n  constructor(logger?: IMastraLogger) {\n    if (logger) {\n      this.logger = logger;\n    } else {\n      // Fallback: create a direct ConsoleLogger instance if none provided\n      this.logger = new ConsoleLogger({\n        name: 'default-console-exporter',\n      });\n    }\n  }\n\n  async exportEvent(event: AITracingEvent): Promise<void> {\n    const span = event.span;\n\n    // Helper to safely stringify metadata (filtering already done by processor)\n    const formatMetadata = (metadata: any) => {\n      try {\n        return JSON.stringify(metadata, null, 2);\n      } catch (error) {\n        const errMsg = error instanceof Error ? error.message : 'Unknown formatting error';\n        return `[Unable to serialize metadata: ${errMsg}]`;\n      }\n    };\n\n    // Helper to format duration\n    const formatDuration = (startTime: Date, endTime?: Date) => {\n      if (!endTime) return 'N/A';\n      const duration = endTime.getTime() - startTime.getTime();\n      return `${duration}ms`;\n    };\n\n    switch (event.type) {\n      case AITracingEventType.SPAN_STARTED:\n        this.logger.info(`🚀 SPAN_STARTED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        this.logger.info(`   Metadata: ${formatMetadata(span.metadata)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      case AITracingEventType.SPAN_ENDED:\n        const duration = formatDuration(span.startTime, span.endTime);\n        this.logger.info(`✅ SPAN_ENDED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Duration: ${duration}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        this.logger.info(`   Final Metadata: ${formatMetadata(span.metadata)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      case AITracingEventType.SPAN_UPDATED:\n        this.logger.info(`📝 SPAN_UPDATED`);\n        this.logger.info(`   Type: ${span.type}`);\n        this.logger.info(`   Name: ${span.name}`);\n        this.logger.info(`   ID: ${span.id}`);\n        this.logger.info(`   Trace ID: ${span.traceId}`);\n        this.logger.info(`   Updated Metadata: ${formatMetadata(span.metadata)}`);\n        this.logger.info('─'.repeat(80));\n        break;\n\n      default:\n        throw new Error(`Tracing event type not implemented: ${(event as any).type}`);\n    }\n  }\n\n  async shutdown(): Promise<void> {\n    this.logger.info('DefaultConsoleExporter shutdown');\n  }\n}\n\n// ============================================================================\n// Default Configuration (defined after classes to avoid circular dependencies)\n// ============================================================================\n\nexport const aiTracingDefaultConfig: AITracingConfig = {\n  serviceName: 'mastra-ai-service',\n  sampling: { type: SamplingStrategyType.ALWAYS },\n  exporters: [new DefaultConsoleExporter()], // Uses its own fallback logger\n  processors: [new SensitiveDataFilter()],\n};\n\n// ============================================================================\n// Default AI Tracing Implementation\n// ============================================================================\n\nexport class DefaultAITracing extends MastraAITracing {\n  constructor(config: AITracingConfig = aiTracingDefaultConfig) {\n    super(config);\n  }\n\n  // ============================================================================\n  // Abstract Method Implementations\n  // ============================================================================\n\n  protected createSpan<TType extends AISpanType>(options: AISpanOptions<TType>): AISpan<TType> {\n    // Simple span creation - base class handles all tracing lifecycle automatically\n    return new DefaultAISpan<TType>(options, this);\n  }\n}\n","/**\n * AI Tracing Registry for Mastra\n *\n * Provides a global registry for AI tracing instances.\n */\n\nimport type { MastraAITracing } from './base';\nimport { SamplingStrategyType } from './types';\n\n// ============================================================================\n// Global AI Tracing Registry\n// ============================================================================\n\n/**\n * Global registry for AI Tracing instances.\n */\nclass AITracingRegistry {\n  private instances = new Map<string, MastraAITracing>();\n  private defaultInstance?: MastraAITracing;\n\n  /**\n   * Register a tracing instance\n   */\n  register(name: string, instance: MastraAITracing, isDefault = false): void {\n    this.instances.set(name, instance);\n    if (isDefault || !this.defaultInstance) {\n      this.defaultInstance = instance;\n    }\n  }\n\n  /**\n   * Get a tracing instance by name\n   */\n  get(name?: string): MastraAITracing | undefined {\n    if (name) {\n      return this.instances.get(name);\n    }\n    return this.defaultInstance;\n  }\n\n  /**\n   * Unregister a tracing instance\n   */\n  unregister(name: string): boolean {\n    const instance = this.instances.get(name);\n    if (instance && instance === this.defaultInstance) {\n      // Find another instance to be the default\n      const remaining = Array.from(this.instances.values()).filter(i => i !== instance);\n      this.defaultInstance = remaining[0];\n    }\n    return this.instances.delete(name);\n  }\n\n  /**\n   * Clear all instances\n   */\n  clear(): void {\n    this.instances.clear();\n    this.defaultInstance = undefined;\n  }\n\n  /**\n   * Get all registered instances\n   */\n  getAll(): ReadonlyMap<string, MastraAITracing> {\n    return new Map(this.instances);\n  }\n}\n\nconst aiTracingRegistry = new AITracingRegistry();\n\n// ============================================================================\n// Registry Management Functions\n// ============================================================================\n\n/**\n * Register an AI tracing instance globally\n */\nexport function registerAITracing(name: string, instance: MastraAITracing, isDefault = false): void {\n  aiTracingRegistry.register(name, instance, isDefault);\n}\n\n/**\n * Get an AI tracing instance from the registry\n */\nexport function getAITracing(name?: string): MastraAITracing | undefined {\n  return aiTracingRegistry.get(name);\n}\n\n/**\n * Unregister an AI tracing instance\n */\nexport function unregisterAITracing(name: string): boolean {\n  return aiTracingRegistry.unregister(name);\n}\n\n/**\n * Clear all AI tracing instances\n */\nexport function clearAITracingRegistry(): void {\n  aiTracingRegistry.clear();\n}\n\n/**\n * Check if AI tracing is available and enabled\n */\nexport function hasAITracing(name?: string): boolean {\n  const tracing = getAITracing(name);\n  if (!tracing) return false;\n\n  const config = tracing.getConfig();\n  const sampling = config.sampling;\n\n  // Check if sampling allows tracing\n  return sampling.type !== SamplingStrategyType.NEVER;\n}\n"]}