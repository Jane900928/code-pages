import type { CoreMessage, CoreSystemMessage, IDGenerator, Message, UIMessage } from 'ai';
import type { MastraMessageV1 } from '../../memory/index.js';
export type MastraMessageContentV2 = {
    format: 2;
    parts: UIMessage['parts'];
    experimental_attachments?: UIMessage['experimental_attachments'];
    content?: UIMessage['content'];
    toolInvocations?: UIMessage['toolInvocations'];
    reasoning?: UIMessage['reasoning'];
    annotations?: UIMessage['annotations'];
    metadata?: Record<string, unknown>;
};
export type MastraMessageV2 = {
    id: string;
    content: MastraMessageContentV2;
    role: 'user' | 'assistant';
    createdAt: Date;
    threadId?: string;
    resourceId?: string;
    type?: string;
};
export type UIMessageWithMetadata = UIMessage & {
    metadata?: Record<string, unknown>;
};
export type MessageInput = UIMessage | UIMessageWithMetadata | Message | MastraMessageV1 | CoreMessage | MastraMessageV2;
type MessageSource = 'memory' | 'response' | 'user' | 'system' | 'context';
export declare class MessageList {
    private messages;
    private systemMessages;
    private taggedSystemMessages;
    private memoryInfo;
    private memoryMessages;
    private newUserMessages;
    private newResponseMessages;
    private userContextMessages;
    private memoryMessagesPersisted;
    private newUserMessagesPersisted;
    private newResponseMessagesPersisted;
    private userContextMessagesPersisted;
    private generateMessageId?;
    private _agentNetworkAppend;
    constructor({ threadId, resourceId, generateMessageId, _agentNetworkAppend, }?: {
        threadId?: string;
        resourceId?: string;
        generateMessageId?: IDGenerator;
    });
    add(messages: string | string[] | MessageInput | MessageInput[], messageSource: MessageSource): this;
    getLatestUserContent(): string | null;
    get get(): {
        all: {
            v2: () => MastraMessageV2[];
            v1: () => MastraMessageV1[];
            ui: () => UIMessageWithMetadata[];
            core: () => CoreMessage[];
            prompt: () => CoreMessage[];
        };
        remembered: {
            v2: () => MastraMessageV2[];
            v1: () => MastraMessageV1[];
            ui: () => UIMessageWithMetadata[];
            core: () => CoreMessage[];
        };
        input: {
            v2: () => MastraMessageV2[];
            v1: () => MastraMessageV1[];
            ui: () => UIMessageWithMetadata[];
            core: () => CoreMessage[];
        };
        response: {
            v2: () => MastraMessageV2[];
        };
    };
    get getPersisted(): {
        remembered: {
            v2: () => MastraMessageV2[];
            v1: () => MastraMessageV1[];
            ui: () => UIMessageWithMetadata[];
            core: () => CoreMessage[];
        };
        input: {
            v2: () => MastraMessageV2[];
            v1: () => MastraMessageV1[];
            ui: () => UIMessageWithMetadata[];
            core: () => CoreMessage[];
        };
        taggedSystemMessages: Record<string, CoreSystemMessage[]>;
        response: {
            v2: () => MastraMessageV2[];
            ui: () => UIMessageWithMetadata[];
        };
    };
    get clear(): {
        input: {
            v2: () => MastraMessageV2[];
        };
    };
    private all;
    private remembered;
    private rememberedPersisted;
    private input;
    private inputPersisted;
    private response;
    private responsePersisted;
    drainUnsavedMessages(): MastraMessageV2[];
    getEarliestUnsavedMessageTimestamp(): number | undefined;
    getSystemMessages(tag?: string): CoreMessage[];
    addSystem(messages: CoreSystemMessage | CoreSystemMessage[] | string | string[] | null, tag?: string): this;
    private convertToCoreMessages;
    private sanitizeUIMessages;
    private addOneSystem;
    private isDuplicateSystem;
    private static toUIMessage;
    private getMessageById;
    private shouldReplaceMessage;
    private addOne;
    private pushMessageToSource;
    /**
     * Pushes a new message part to the latest message.
     * @param latestMessage - The latest message to push the part to.
     * @param newMessage - The new message to push the part from.
     * @param part - The part to push.
     * @param insertAt - The index at which to insert the part. Optional.
     */
    private pushNewMessagePart;
    /**
     * Upserts parts of messageV2 into latestMessage based on the anchorMap.
     * This is used when appending a message to the last assistant message to ensure that parts are inserted in the correct order.
     * @param latestMessage - The latest message to upsert parts into.
     * @param messageV2 - The message to upsert parts from.
     * @param anchorMap - The anchor map to use for upserting parts.
     */
    private addPartsToLatestMessage;
    private inputToMastraMessageV2;
    private lastCreatedAt?;
    private generateCreatedAt;
    private newMessageId;
    private mastraMessageV1ToMastraMessageV2;
    private hydrateMastraMessageV2Fields;
    private vercelUIMessageToMastraMessageV2;
    private vercelCoreMessageToMastraMessageV2;
    static isVercelUIMessage(msg: MessageInput): msg is UIMessage | UIMessageWithMetadata;
    static isVercelCoreMessage(msg: MessageInput): msg is CoreMessage;
    static isMastraMessage(msg: MessageInput): msg is MastraMessageV2 | MastraMessageV1;
    static isMastraMessageV1(msg: MessageInput): msg is MastraMessageV1;
    static isMastraMessageV2(msg: MessageInput): msg is MastraMessageV2;
    private static getRole;
    private static cacheKeyFromParts;
    private static coreContentToString;
    private static cacheKeyFromContent;
    private static messagesAreEqual;
}
export {};
//# sourceMappingURL=index.d.ts.map