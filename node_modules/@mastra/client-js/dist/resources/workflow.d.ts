import type { RuntimeContext } from '@mastra/core/runtime-context';
import type { ClientOptions, GetWorkflowResponse, GetWorkflowRunsResponse, GetWorkflowRunsParams, WorkflowRunResult, WorkflowWatchResult, GetWorkflowRunByIdResponse, GetWorkflowRunExecutionResultResponse } from '../types.js';
import { BaseResource } from './base.js';
export declare class Workflow extends BaseResource {
    private workflowId;
    constructor(options: ClientOptions, workflowId: string);
    /**
     * Creates an async generator that processes a readable stream and yields workflow records
     * separated by the Record Separator character (\x1E)
     *
     * @param stream - The readable stream to process
     * @returns An async generator that yields parsed records
     */
    private streamProcessor;
    /**
     * Retrieves details about the workflow
     * @returns Promise containing workflow details including steps and graphs
     */
    details(): Promise<GetWorkflowResponse>;
    /**
     * Retrieves all runs for a workflow
     * @param params - Parameters for filtering runs
     * @returns Promise containing workflow runs array
     */
    runs(params?: GetWorkflowRunsParams): Promise<GetWorkflowRunsResponse>;
    /**
     * Retrieves a specific workflow run by its ID
     * @param runId - The ID of the workflow run to retrieve
     * @returns Promise containing the workflow run details
     */
    runById(runId: string): Promise<GetWorkflowRunByIdResponse>;
    /**
     * Retrieves the execution result for a specific workflow run by its ID
     * @param runId - The ID of the workflow run to retrieve the execution result for
     * @returns Promise containing the workflow run execution result
     */
    runExecutionResult(runId: string): Promise<GetWorkflowRunExecutionResultResponse>;
    /**
     * Cancels a specific workflow run by its ID
     * @param runId - The ID of the workflow run to cancel
     * @returns Promise containing a success message
     */
    cancelRun(runId: string): Promise<{
        message: string;
    }>;
    /**
     * Sends an event to a specific workflow run by its ID
     * @param params - Object containing the runId, event and data
     * @returns Promise containing a success message
     */
    sendRunEvent(params: {
        runId: string;
        event: string;
        data: unknown;
    }): Promise<{
        message: string;
    }>;
    /**
     * Creates a new workflow run
     * @param params - Optional object containing the optional runId
     * @returns Promise containing the runId of the created run
     */
    createRun(params?: {
        runId?: string;
    }): Promise<{
        runId: string;
    }>;
    /**
     * Creates a new workflow run (alias for createRun)
     * @param params - Optional object containing the optional runId
     * @returns Promise containing the runId of the created run
     */
    createRunAsync(params?: {
        runId?: string;
    }): Promise<{
        runId: string;
    }>;
    /**
     * Starts a workflow run synchronously without waiting for the workflow to complete
     * @param params - Object containing the runId, inputData and runtimeContext
     * @returns Promise containing success message
     */
    start(params: {
        runId: string;
        inputData: Record<string, any>;
        runtimeContext?: RuntimeContext | Record<string, any>;
    }): Promise<{
        message: string;
    }>;
    /**
     * Resumes a suspended workflow step synchronously without waiting for the workflow to complete
     * @param params - Object containing the runId, step, resumeData and runtimeContext
     * @returns Promise containing success message
     */
    resume({ step, runId, resumeData, ...rest }: {
        step: string | string[];
        runId: string;
        resumeData?: Record<string, any>;
        runtimeContext?: RuntimeContext | Record<string, any>;
    }): Promise<{
        message: string;
    }>;
    /**
     * Starts a workflow run asynchronously and returns a promise that resolves when the workflow is complete
     * @param params - Object containing the optional runId, inputData and runtimeContext
     * @returns Promise containing the workflow execution results
     */
    startAsync(params: {
        runId?: string;
        inputData: Record<string, any>;
        runtimeContext?: RuntimeContext | Record<string, any>;
    }): Promise<WorkflowRunResult>;
    /**
     * Starts a workflow run and returns a stream
     * @param params - Object containing the optional runId, inputData and runtimeContext
     * @returns Promise containing the workflow execution results
     */
    stream(params: {
        runId?: string;
        inputData: Record<string, any>;
        runtimeContext?: RuntimeContext;
    }): Promise<import("stream/web").ReadableStream<{
        type: string;
        payload: any;
    }>>;
    /**
     * Resumes a suspended workflow step asynchronously and returns a promise that resolves when the workflow is complete
     * @param params - Object containing the runId, step, resumeData and runtimeContext
     * @returns Promise containing the workflow resume results
     */
    resumeAsync(params: {
        runId: string;
        step: string | string[];
        resumeData?: Record<string, any>;
        runtimeContext?: RuntimeContext | Record<string, any>;
    }): Promise<WorkflowRunResult>;
    /**
     * Watches workflow transitions in real-time
     * @param runId - Optional run ID to filter the watch stream
     * @returns AsyncGenerator that yields parsed records from the workflow watch stream
     */
    watch({ runId }: {
        runId?: string;
    }, onRecord: (record: WorkflowWatchResult) => void): Promise<void>;
    /**
     * Creates a new ReadableStream from an iterable or async iterable of objects,
     * serializing each as JSON and separating them with the record separator (\x1E).
     *
     * @param records - An iterable or async iterable of objects to stream
     * @returns A ReadableStream emitting the records as JSON strings separated by the record separator
     */
    static createRecordStream(records: Iterable<any> | AsyncIterable<any>): ReadableStream;
}
//# sourceMappingURL=workflow.d.ts.map